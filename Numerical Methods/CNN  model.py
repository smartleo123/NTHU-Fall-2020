# -*- coding: utf-8 -*-
"""數值方法 作業2. CNN模型實作 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17GiwQ9di-3Qqa-aykOLEgEG-0s0AKrpx
"""

# Commented out IPython magic to ensure Python compatibility.
# import common used packages
# %matplotlib inline

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from tensorflow.keras.datasets import fashion_mnist # import the fashion_mnist dataset

"""## data preprocessing"""

(x_train, y_train), (x_test, y_test) = fashion_mnist.load_data()

x_train.shape

x_test.shape

x_train = x_train.reshape(60000, 28, 28, 1) / 255
x_test = x_test.reshape(10000, 28, 28, 1) / 255

x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)

from tensorflow.keras.utils import to_categorical
y_train = to_categorical(y_train, 10)
y_test = to_categorical(y_test, 10)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dropout
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.optimizers import SGD

"""## Try the easiest CNN sequencial model and start training """

model = Sequential()

model.add(Conv2D(64,(3,3),padding='same',input_shape = (28,28,1), activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))

model.add(Conv2D(128,(3,3),padding='same', activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))

model.add(Conv2D(256,(3,3), padding='same', activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))

model.add(Conv2D(512,(3,3), padding='same', activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))

model.add(Flatten())

model.add(Dense(64, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(10 ,activation='softmax'))

model.summary()

model.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics = ['accuracy'])

model.fit(x_train, y_train, batch_size=64, epochs=16 , validation_split=0.2)

score = model.evaluate(x_test,y_test)
loss, acc = score
print('資料正確率為:', acc)

class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat','Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

result = model.predict_classes(x_test)

def mypredict(n):
    print('CNN預測結果為:', class_names[result[n]])
    X = x_test[n].reshape(28,28)
    plt.imshow(X,cmap='Greys');

from ipywidgets import interact_manual

interact_manual(mypredict, n=(0,9999));

model2 = Sequential()

model2.add(Conv2D(64,(3,3),padding='same',input_shape = (28,28,1), activation='tanh'))
model2.add(MaxPooling2D(pool_size=(2,2)))

model2.add(Conv2D(128,(3,3),padding='same', activation='tanh'))
model2.add(MaxPooling2D(pool_size=(2,2)))

model2.add(Conv2D(256,(3,3), padding='same', activation='tanh'))
model2.add(MaxPooling2D(pool_size=(2,2)))

model2.add(Conv2D(512,(3,3), padding='same', activation='tanh'))
model2.add(MaxPooling2D(pool_size=(2,2)))


model2.add(Flatten())

model2.add(Dense(64, activation='tanh'))
model2.add(Dense(128, activation='tanh'))
model2.add(Dense(256, activation='tanh'))
model2.add(Dense(10 ,activation='softmax'))

model2.summary()

model2.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics = ['accuracy'])

model.fit(x_train, y_train, batch_size=64, epochs=16 , validation_split=0.1)

score = model.evaluate(x_test,y_test)
loss, acc = score
print('資料正確率為:', acc)

"""## Try with resnet"""

from keras.models import Model
from keras.layers import Input, add, Activation
from keras.layers.merge import concatenate

input_img = Input(shape=(28, 28, 1))

def residual_module(layer_in, n_filters):

  projection_in = layer_in
  if layer_in.shape[-1] != n_filters:
    projection_in = Conv2D(n_filters, (1,1), padding='same', activation='relu')(layer_in)
  conv1 = Conv2D(n_filters, (3,3), padding='same', activation='relu')(layer_in)
  conv2 = Conv2D(n_filters, (3,3), padding='same', activation='linear')(conv1)
  layer_out = add([conv2, projection_in])
  layer_out = Activation('relu')(layer_out)
  return layer_out

out_1 = residual_module(input_img, 8) # First residual module
out_2 = residual_module(out_1, 16) # Second residual module
out_3 = residual_module(out_2, 32) # Third residual module
out_4 = residual_module(out_3, 64) # Fourth residual module
out_c = concatenate([out_1, out_2, out_3, out_4], axis = 3)

flat = Flatten()(out_c)
dense_1 = Dense(512, activation='relu')(flat)
dense_2 = Dense(256, activation='relu')(dense_1)
dense_3 = Dense(128, activation='relu')(dense_2)
output = Dense(10, activation='softmax')(dense_3)

model_resnet = Model(input_img, output) # build the model
model_resnet.compile(optimizer='adam', loss='categorical_crossentropy',metrics=['accuracy'])
model_resnet.fit(x_train, y_train, epochs=16, batch_size=64, validation_split=0.2)

model_resnet.summary()

score = model_resnet.evaluate(x_test,y_test)
loss, acc = score
print('資料正確率為:', acc)
